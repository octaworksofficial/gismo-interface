<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>FluxGarage RoboEyes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: #000000;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
        }

        #roboEyesCanvas {
            display: block;
            border: none;
            outline: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        /* Fullscreen styles */
        body.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
        }

        /* Hide cursor after 3 seconds of inactivity */
        body.hide-cursor {
            cursor: none;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading.show {
            opacity: 1;
        }

        /* Settings button - very subtle */
        .settings-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            z-index: 2000;
            transition: all 0.3s ease;
            opacity: 0.3;
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            opacity: 0.8;
            transform: scale(1.1);
        }

        .settings-btn:active {
            transform: scale(0.95);
        }

        /* Hide settings button in fullscreen */
        body.fullscreen .settings-btn {
            opacity: 0;
            pointer-events: none;
        }

        /* Speech Recognition Indicator */
        .speech-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: #ffffff;
            font-size: 12px;
            font-family: monospace;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .speech-indicator.listening {
            opacity: 1;
            background: rgba(0, 170, 255, 0.8);
            animation: pulse 1.5s infinite;
        }

        .speech-indicator.thinking {
            opacity: 1;
            background: rgba(255, 165, 0, 0.8);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* API Response Display */
        .response-display {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 80vw;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: #ffffff;
            font-size: 14px;
            font-family: monospace;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-align: center;
            line-height: 1.4;
        }

        .response-display.show {
            opacity: 0.9;
        }

        /* Hide speech UI in fullscreen */
        body.fullscreen .speech-indicator,
        body.fullscreen .response-display {
            opacity: 0;
            pointer-events: none;
        }

        /* Thinking Bubble Animation */
        .thinking-bubble {
            position: fixed;
            top: 20%;
            right: 15%;
            background: rgba(255, 170, 0, 0.9);
            border: 2px solid rgba(255, 170, 0, 1);
            border-radius: 20px;
            padding: 15px 20px;
            color: #000;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 3000;
            opacity: 0;
            transform: scale(0.8) translateY(20px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(255, 170, 0, 0.3);
            max-width: 200px;
            text-align: center;
            animation: float 2s ease-in-out infinite;
        }

        .thinking-bubble.show {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Bubble tail */
        .thinking-bubble::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 30px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid rgba(255, 170, 0, 0.9);
        }

        /* Small thinking dots */
        .thinking-bubble::after {
            content: 'ðŸ’­';
            position: absolute;
            bottom: -35px;
            left: 15px;
            font-size: 18px;
            animation: pulse 1.5s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-5px) scale(1.02); }
        }

        /* Hide thinking bubble in fullscreen */
        body.fullscreen .thinking-bubble {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="roboEyesCanvas"></canvas>
    <div class="loading" id="loading">FluxGarage RoboEyes Loading...</div>
    
    <!-- Settings button - very subtle -->
    <button class="settings-btn" id="settingsBtn" title="Settings">âš™</button>
    
    <!-- Speech Recognition UI -->
    <div class="speech-indicator" id="speechIndicator">ðŸŽ¤ Dinliyor...</div>
    <div class="response-display" id="responseDisplay"></div>
    
    <!-- Thinking Bubble -->
    <div class="thinking-bubble" id="thinkingBubble">
        <div id="thinkingText">ðŸ¤” Hmm...</div>
    </div>
    
    <script src="RoboEyes.js"></script>
    <script>
        class RoboEyesApp {
            constructor() {
                this.canvas = document.getElementById('roboEyesCanvas');
                this.loading = document.getElementById('loading');
                this.speechIndicator = document.getElementById('speechIndicator');
                this.responseDisplay = document.getElementById('responseDisplay');
                this.thinkingBubble = document.getElementById('thinkingBubble');
                this.thinkingText = document.getElementById('thinkingText');
                this.roboEyes = null;
                
                // Robot states
                this.robotState = 'NORMAL'; // NORMAL, LISTENING, THINKING
                this.emotions = [
                    { name: 'DEFAULT', code: 0 },
                    { name: 'TIRED', code: 1 },
                    { name: 'ANGRY', code: 2 },
                    { name: 'HAPPY', code: 3 },
                    { name: 'THINKING', code: 4 },
                    { name: 'CRYING', code: 5 }
                ];
                this.currentEmotionIndex = 0;
                this.emotionInterval = null;
                this.cursorTimeout = null;
                
                // Speech Recognition
                this.recognition = null;
                this.isListening = false;
                this.wakeWord = 'gizmo';
                this.isAwake = false;
                this.silenceTimer = null;
                this.commandTimer = null; // Timer for auto-sending command after silence
                this.currentCommand = ''; // Store the current command being built
                this.lastSpeechTime = null; // Track when last speech was detected
                
                // Thinking bubble
                this.thinkingMessages = [
                    'ðŸ¤” Hmm...',
                    'ðŸ’­ ...',
                    'ðŸ§  Analiz...',
                    'âš¡ Ä°ÅŸliyorum...',
                    'ðŸ”„ Hesap...',
                    'ðŸ’¡ Ã‡Ã¶zÃ¼m...',
                    'ðŸŽ¯ Odak...',
                    'â­ ...'
                ];
                this.thinkingInterval = null;
                
                // Blinking animation for normal mode
                this.blinkInterval = null;
                this.isBlinking = false;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.initializeRoboEyes();
                this.setupEventListeners();
                this.autoEnterFullscreen();
                this.setupCursorHiding();
                this.setupSettingsButton();
                
                // Initialize speech recognition after a short delay
                setTimeout(() => {
                    this.initializeSpeechRecognition();
                }, 2000); // Increased delay for better stability
            }
            
            setupCanvas() {
                // Calculate optimal canvas size based on viewport (bigger eyes)
                const minDimension = Math.min(window.innerWidth, window.innerHeight);
                
                // Ensure minimum size for large eyes (150+80+150 = 380 + padding)
                const minRequiredSize = 450; 
                const canvasSize = Math.max(minRequiredSize, Math.floor(minDimension * 0.95));
                
                this.canvas.width = canvasSize;
                this.canvas.height = canvasSize;
                this.canvas.style.width = canvasSize + 'px';
                this.canvas.style.height = canvasSize + 'px';
                
                // Ensure canvas is centered and fixed
                this.canvas.style.position = 'fixed';
                this.canvas.style.top = '50%';
                this.canvas.style.left = '50%';
                this.canvas.style.transform = 'translate(-50%, -50%)';
                this.canvas.style.zIndex = '1000';
            }
            
            initializeRoboEyes() {
                this.loading.classList.add('show');
                
                setTimeout(() => {
                    this.roboEyes = new RoboEyes(this.canvas);
                    this.roboEyes.begin(this.canvas.width, this.canvas.height, 60); // 60 FPS
                    this.roboEyes.setDisplayColors('#000000', '#00aaff');
                    this.roboEyes.setAutoblinker(false); // Disable auto blink, we'll handle it manually
                    this.roboEyes.setCuriosity(false); // Disable mouse/touch tracking
                    this.roboEyes.open(); // Start with eyes open
                    
                    // Force eyes to be fully open initially
                    this.roboEyes.eyeL_open = true;
                    this.roboEyes.eyeR_open = true;
                    this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault;
                    this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault;
                    
                    // Set default emotion and colors (blue eyes)
                    this.roboEyes.setMood(0); // DEFAULT emotion
                    this.roboEyes.setDisplayColors('#000000', '#00aaff'); // Blue eyes
                    this.roboEyes.setSweat(false);
                    this.roboEyes.setHFlicker(false);
                    this.roboEyes.setVFlicker(false);
                    
                    // Start custom blinking for normal mode
                    this.startBlinking();
                    
                    // Start the animation loop
                    this.startAnimationLoop();
                    
                    this.loading.classList.remove('show');
                }, 500);
            }
            
            startAnimationLoop() {
                const animate = () => {
                    if (this.roboEyes) {
                        this.roboEyes.update();
                    }
                    requestAnimationFrame(animate);
                };
                animate();
            }
            
            setupEventListeners() {
                // Mouse/touch tracking disabled - robot eyes stay centered
                
                // Double tap/click for fullscreen
                let lastTap = 0;
                document.addEventListener('touchend', (e) => {
                    const currentTime = Date.now();
                    if (currentTime - lastTap < 500) {
                        this.toggleFullscreen();
                    }
                    lastTap = currentTime;
                    e.preventDefault();
                });
                
                document.addEventListener('dblclick', () => {
                    this.toggleFullscreen();
                });
                
                // Resize handler
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    if (this.roboEyes) {
                        this.roboEyes.begin(this.canvas.width, this.canvas.height, 60);
                    }
                });
                
                // Prevent context menu
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'f':
                            this.toggleFullscreen();
                            break;
                        case 'b':
                            if (this.roboEyes) this.roboEyes.blink();
                            break;
                        case 'c':
                            if (this.roboEyes) this.roboEyes.setCyclops(!this.roboEyes.cyclops);
                            break;
                        case 'r':
                            if (this.roboEyes) this.roboEyes.anim_confused();
                            break;
                        case 'l':
                            if (this.roboEyes) this.roboEyes.anim_laugh();
                            break;
                        case 's':
                            if (this.roboEyes) this.roboEyes.setSweat(!this.roboEyes.sweat);
                            break;
                        case 'escape':
                            if (document.fullscreenElement) {
                                document.exitFullscreen();
                            }
                            break;
                    }
                    e.preventDefault();
                });
            }
            
            showCursor() {
                // Cursor management disabled - no mouse tracking
            }
            
            setupCursorHiding() {
                // Cursor hiding disabled - no mouse interaction
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().then(() => {
                        document.body.classList.add('fullscreen');
                        this.lockOrientationLandscape();
                    }).catch(() => {
                        document.body.classList.add('fullscreen');
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        document.body.classList.remove('fullscreen');
                    });
                }
            }
            
            lockOrientationLandscape() {
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(() => {});
                }
            }
            
            autoEnterFullscreen() {
                // Auto fullscreen on mobile devices
                if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                    setTimeout(() => {
                        this.toggleFullscreen();
                    }, 2000);
                }
            }
            
            setupCursorHiding() {
                this.showCursor();
            }
            
            showCursor() {
                document.body.classList.remove('hide-cursor');
                
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                }
                
                this.cursorTimeout = setTimeout(() => {
                    document.body.classList.add('hide-cursor');
                }, 3000);
            }
            
            setupSettingsButton() {
                const settingsBtn = document.getElementById('settingsBtn');
                settingsBtn.addEventListener('click', () => {
                    // Navigate to settings page
                    window.location.href = 'settings.html';
                });
            }
            
            async initializeSpeechRecognition() {
                console.log('ðŸŽ¤ Initializing speech recognition...');
                
                // Check if speech recognition is supported
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('âŒ Speech recognition not supported');
                    this.speechIndicator.textContent = 'âŒ Mikrofon desteklenmiyor';
                    this.speechIndicator.style.opacity = '1';
                    return;
                }
                
                // Request microphone permission first
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('âœ… Microphone permission granted');
                } catch (error) {
                    console.error('âŒ Microphone permission denied:', error);
                    this.speechIndicator.textContent = 'âŒ Mikrofon izni gerekli';
                    this.speechIndicator.style.opacity = '1';
                    return;
                }
                
                // Create speech recognition instance
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                // Configure recognition
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = 'tr-TR'; // Turkish language
                this.recognition.maxAlternatives = 1;
                
                // Event handlers
                this.recognition.onstart = () => {
                    console.log('ðŸŽ¤ Speech recognition started');
                    this.isListening = true;
                    this.setRobotState('NORMAL');
                };
                
                this.recognition.onresult = (event) => {
                    this.handleSpeechResult(event);
                };
                
                this.recognition.onerror = (event) => {
                    console.error('âŒ Speech recognition error:', event.error);
                    this.speechIndicator.textContent = `âŒ Hata: ${event.error}`;
                    this.speechIndicator.style.opacity = '1';
                    
                    // Reset state on error
                    this.isListening = false;
                    
                    // Don't restart on critical errors
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        setTimeout(() => {
                            if (!this.isListening) {
                                this.restartListening();
                            }
                        }, 2000);
                    }
                };
                
                this.recognition.onend = () => {
                    console.log('ðŸŽ¤ Speech recognition ended');
                    this.isListening = false;
                    
                    // Only restart if in normal state and not manually stopped
                    if (this.robotState === 'NORMAL' && !this.isAwake) {
                        setTimeout(() => {
                            this.restartListening();
                        }, 500);
                    }
                };
                
                // Test webhook connection on startup
                this.testWebhookConnection();
                
                // Start listening
                this.startListening();
            }
            
            startListening() {
                if (this.recognition && !this.isListening) {
                    try {
                        this.recognition.start();
                    } catch (error) {
                        console.error('Error starting speech recognition:', error);
                        setTimeout(() => this.startListening(), 1000);
                    }
                }
            }
            
            stopListening() {
                if (this.recognition && this.isListening) {
                    try {
                        console.log('ðŸ”‡ Stopping speech recognition for thinking mode');
                        this.recognition.stop();
                        this.isListening = false;
                    } catch (error) {
                        console.error('Error stopping speech recognition:', error);
                    }
                }
            }
            
            restartListening() {
                setTimeout(() => {
                    if (this.robotState === 'NORMAL') {
                        this.startListening();
                    }
                }, 500);
            }
            
            handleSpeechResult(event) {
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                const fullTranscript = (finalTranscript + interimTranscript).toLowerCase().trim();
                console.log('ðŸŽ¤ Heard:', fullTranscript);
                
                if (!this.isAwake) {
                    // Default mode - react to any sound with eye movement
                    if (fullTranscript) {
                        // Eye movement animation when hearing sound in default mode
                        if (this.roboEyes && this.robotState === 'NORMAL') {
                            // Randomize between different attention animations
                            const animations = ['lookAround', 'quickGlance'];
                            const selectedAnim = animations[Math.floor(Math.random() * animations.length)];
                            
                            if (selectedAnim === 'lookAround') {
                                this.roboEyes.anim_lookAround();
                            } else {
                                this.roboEyes.anim_quickGlance();
                            }
                        }
                    }
                    
                    // Check for wake word
                    if (fullTranscript.includes(this.wakeWord)) {
                        console.log('ðŸ¤– Wake word detected!');
                        // Dramatic animation sequence for wake word detection
                        if (this.roboEyes) {
                            // First: intense pulse
                            this.roboEyes.anim_activeListeningPulse();
                            // Then: scanning effect after 300ms
                            setTimeout(() => {
                                this.roboEyes.anim_scanningEffect();
                            }, 300);
                            // Finally: double blink to show recognition
                            setTimeout(() => {
                                this.roboEyes.blink();
                                setTimeout(() => {
                                    this.roboEyes.blink();
                                }, 200);
                            }, 800);
                        }
                        this.wakeUp();
                        return;
                    }
                    // Show what's being heard while waiting for wake word
                    if (fullTranscript) {
                        this.speechIndicator.textContent = `ðŸŽ¤ "${fullTranscript}"`;
                        this.speechIndicator.style.opacity = '0.7';
                        setTimeout(() => {
                            if (!this.isAwake) {
                                this.speechIndicator.style.opacity = '0.3';
                                this.speechIndicator.textContent = 'ðŸŽ¤ Sessizce dinliyor...';
                            }
                        }, 2000);
                    }
                } else {
                    // Robot is awake, process command
                    this.lastSpeechTime = Date.now();
                    
                    // Sound processing animation when in listening mode
                    if (fullTranscript && this.roboEyes && this.robotState === 'LISTENING') {
                        // More dramatic animations for command listening
                        const animations = ['commandListeningIntense', 'scanningEffect', 'activeListeningPulse'];
                        const selectedAnim = animations[Math.floor(Math.random() * animations.length)];
                        
                        if (selectedAnim === 'commandListeningIntense') {
                            this.roboEyes.anim_commandListeningIntense();
                        } else if (selectedAnim === 'scanningEffect') {
                            this.roboEyes.anim_scanningEffect();
                        } else {
                            this.roboEyes.anim_activeListeningPulse();
                        }
                    }
                    
                    if (finalTranscript) {
                        // Final result - add to current command
                        this.currentCommand += ' ' + finalTranscript;
                        this.currentCommand = this.currentCommand.trim();
                        console.log('ðŸ¤– Command building:', this.currentCommand);
                        
                        // Start/restart the command timer for auto-send after 2 seconds of silence
                        this.startCommandTimer();
                        
                    } else if (interimTranscript) {
                        // Show interim results while listening
                        const displayCommand = this.currentCommand + ' ' + interimTranscript;
                        this.speechIndicator.textContent = `ðŸŽ¤ "${displayCommand.trim()}"`;
                        this.resetSilenceTimer();
                        
                        // More noticeable animation for interim results
                        if (this.roboEyes && this.robotState === 'LISTENING') {
                            // Alternate between pulse and quick movements
                            const interimAnimations = ['activeListeningPulse', 'soundProcessing'];
                            const selectedAnim = interimAnimations[Math.floor(Math.random() * interimAnimations.length)];
                            
                            if (selectedAnim === 'activeListeningPulse') {
                                this.roboEyes.anim_activeListeningPulse();
                            } else {
                                this.roboEyes.anim_soundProcessing();
                            }
                        }
                    }
                }
            }
            
            wakeUp() {
                console.log('ðŸ¤– Robot woke up! Listening for command...');
                this.isAwake = true;
                this.currentCommand = ''; // Reset command
                this.setRobotState('LISTENING');
                this.resetSilenceTimer();
            }
            
            startCommandTimer() {
                // Clear existing timer to prevent conflicts
                if (this.commandTimer) {
                    clearTimeout(this.commandTimer);
                    this.commandTimer = null;
                }
                
                // Start 4-second timer for auto-sending command
                this.commandTimer = setTimeout(() => {
                    if (this.isAwake && this.currentCommand.trim()) {
                        console.log('ðŸ¤– Auto-sending command after silence:', this.currentCommand);
                        this.processCommand(this.currentCommand.trim());
                        this.isAwake = false;
                        this.currentCommand = '';
                        this.setRobotState('THINKING');
                    }
                }, 2000); // 4 seconds of silence (increased from 2)
            }
            
            resetSilenceTimer() {
                // Clear existing timer to prevent conflicts
                if (this.silenceTimer) {
                    clearTimeout(this.silenceTimer);
                    this.silenceTimer = null;
                }
                
                this.silenceTimer = setTimeout(() => {
                    if (this.isAwake) {
                        console.log('ðŸ¤– No command received, going back to sleep');
                        this.isAwake = false;
                        this.currentCommand = '';
                        this.setRobotState('NORMAL');
                        
                        // Clear command timer too
                        if (this.commandTimer) {
                            clearTimeout(this.commandTimer);
                            this.commandTimer = null;
                        }
                    }
                }, 8000); // 8 seconds total timeout
            }
            
            setRobotState(state) {
                console.log('ðŸ¤– Robot state changed to:', state);
                this.robotState = state;
                
                switch (state) {
                    case 'NORMAL':
                        this.speechIndicator.className = 'speech-indicator';
                        this.speechIndicator.textContent = 'ðŸŽ¤ Sessizce dinliyor...';
                        this.speechIndicator.style.opacity = '0.3';
                        this.hideThinkingBubble(); // Only hide thinking bubble, not response
                        
                        // Restart listening when back to normal
                        if (!this.isListening) {
                            this.startListening();
                        }
                        
                        // Reset to default blue eyes
                        if (this.roboEyes) {
                            this.roboEyes.setMood(0); // DEFAULT emotion
                            this.roboEyes.setDisplayColors('#000000', '#00aaff'); // Blue eyes
                            this.roboEyes.setTearColor(null); // Reset tear color
                            this.roboEyes.setWateryEyes(false); // Reset watery eyes
                            this.roboEyes.setSweat(false);
                            this.roboEyes.setHFlicker(false);
                            this.roboEyes.setVFlicker(false);
                            
                            // Reset eye sizes to default
                            this.roboEyes.eyeLwidthCurrent = this.roboEyes.eyeLwidthDefault;
                            this.roboEyes.eyeRwidthCurrent = this.roboEyes.eyeRwidthDefault;
                            this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault;
                            this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault;
                        }
                        
                        // Start blinking for normal mode
                        this.startBlinking();
                        break;
                        
                    case 'LISTENING':
                        this.speechIndicator.className = 'speech-indicator listening';
                        this.speechIndicator.textContent = 'ðŸŽ¤ Komut bekleniyor...';
                        this.speechIndicator.style.opacity = '1';
                        this.hideThinkingBubble(); // Only hide thinking bubble, not response
                        
                        // Ensure listening is active
                        if (!this.isListening) {
                            this.startListening();
                        }
                        
                        // Keep blue eyes while listening - ENLARGED for attention
                        if (this.roboEyes) {
                            this.roboEyes.setMood(0); // DEFAULT emotion
                            this.roboEyes.setDisplayColors('#000000', '#00aaff'); // Blue eyes
                            this.roboEyes.setTearColor(null); // Reset tear color
                            this.roboEyes.setWateryEyes(false); // Reset watery eyes
                            this.roboEyes.setSweat(false);
                            this.roboEyes.setHFlicker(false);
                            this.roboEyes.setVFlicker(false);
                            
                            // Enlarge eyes by 30% for listening mode
                            this.roboEyes.eyeLwidthCurrent = this.roboEyes.eyeLwidthDefault * 2;
                            this.roboEyes.eyeRwidthCurrent = this.roboEyes.eyeRwidthDefault * 2;
                            this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault * 2;
                            this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault * 2;
                        }
                        
                        // Stop blinking while listening for commands
                        this.stopBlinking();
                        break;
                        
                    case 'THINKING':
                        this.speechIndicator.className = 'speech-indicator thinking';
                        this.speechIndicator.textContent = 'ðŸ§  DÃ¼ÅŸÃ¼nÃ¼yor...';
                        this.speechIndicator.style.opacity = '1';
                        this.showThinkingBubble(); // Show animated thinking bubble
                        
                        // Stop blinking while thinking
                        this.stopBlinking();
                        
                        // STOP listening while thinking
                        this.stopListening();
                        
                        // Force THINKING emotion when in thinking state
                        if (this.roboEyes) {
                            this.roboEyes.setMood(4); // THINKING emotion code
                            this.roboEyes.setDisplayColors('#000000', '#ffaa00'); // Orange eyes
                            this.roboEyes.setTearColor(null); // Reset tear color
                            this.roboEyes.setWateryEyes(false); // Reset watery eyes
                            this.roboEyes.setVFlicker(true, 3); // Thinking flicker
                            
                            // Reset eye sizes to default for thinking
                            this.roboEyes.eyeLwidthCurrent = this.roboEyes.eyeLwidthDefault;
                            this.roboEyes.eyeRwidthCurrent = this.roboEyes.eyeRwidthDefault;
                            this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault;
                            this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault;
                        }
                        break;
                }
            }
            
            async processCommand(command) {
                console.log('ðŸ¤– Processing command:', command);
                
                // First, test if the webhook is reachable
                await this.testWebhookConnection();
                
                try {
                    // Send to webhook API
                    console.log('ðŸŒ Sending request to API...');
                    const response = await fetch('https://n8n-production-14b9.up.railway.app/webhook/user-prompt', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/plain'
                        },
                        body: command
                    });
                    
                    console.log('ðŸ“¡ Response status:', response.status);
                    console.log('ðŸ“¡ Response ok:', response.ok);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const responseText = await response.text();
                    console.log('âœ… API Response:', responseText);
                    this.showResponse(responseText);
                    
                    // DON'T return to normal state immediately - let emotion stay
                    // this.setRobotState('NORMAL'); // Removed this line
                    this.hideThinkingBubble(); // Only hide thinking bubble
                    this.restartListening();
                    
                    // But keep the response text visible for 3 more seconds
                    setTimeout(() => {
                        this.hideResponse();
                    }, 3000);
                    
                } catch (error) {
                    console.error('âŒ API Error Details:', error);
                    console.error('âŒ Error message:', error.message);
                    console.error('âŒ Error stack:', error.stack);
                    
                    // Show more specific error message
                    if (error.message.includes('Failed to fetch') || error.message.includes('Load failed')) {
                        console.log('ðŸ”„ Trying alternative approach...');
                        // Try with different headers and no-cors mode
                        try {
                            await fetch('https://n8n-production-14b9.up.railway.app/webhook/user-prompt', {
                                method: 'POST',
                                mode: 'no-cors',
                                headers: {
                                    'Content-Type': 'text/plain'
                                },
                                body: command
                            });
                            this.showResponse('Komut gÃ¶nderildi (no-cors mode)');
                        } catch (secondError) {
                            this.showResponse('AÄŸ baÄŸlantÄ±sÄ± hatasÄ±: API sunucusuna ulaÅŸÄ±lamÄ±yor. Ä°nternet baÄŸlantÄ±nÄ±zÄ± kontrol edin.');
                        }
                    } else if (error.message.includes('HTTP')) {
                        this.showResponse(`Sunucu hatasÄ±: ${error.message}`);
                    } else {
                        this.showResponse(`Hata: ${error.message}`);
                    }
                    
                    // DON'T return to normal state immediately for errors too
                    // this.setRobotState('NORMAL'); // Removed this line
                    this.hideThinkingBubble(); // Only hide thinking bubble
                    this.restartListening();
                    
                    // But keep the error message visible for 3 more seconds
                    setTimeout(() => {
                        this.hideResponse();
                    }, 3000);
                }
            }
            
            async testWebhookConnection() {
                try {
                    console.log('ðŸ” Testing webhook connection...');
                    const testResponse = await fetch('https://n8n-production-14b9.up.railway.app/webhook/user-prompt', {
                        method: 'OPTIONS'
                    });
                    console.log('âœ… Webhook reachable, status:', testResponse.status);
                } catch (error) {
                    console.warn('âš ï¸ Webhook test failed:', error.message);
                }
            }
            
            showResponse(text) {
                // Parse API response format: "0#/#F#/#Message"
                // Split by "#/#" and take parts
                let displayText = text;
                let emotionCode = 0; // Default emotion
                
                if (text.includes('#/#')) {
                    const parts = text.split('#/#');
                    
                    // First part is emotion code (0-5)
                    if (parts.length >= 1) {
                        const firstPart = parts[0].trim();
                        const parsedEmotion = parseInt(firstPart);
                        if (!isNaN(parsedEmotion) && parsedEmotion >= 0 && parsedEmotion <= 5) {
                            emotionCode = parsedEmotion;
                        }
                    }
                    
                    // Last part is the message
                    displayText = parts[parts.length - 1];
                    
                    console.log('ðŸ“± Parsed response parts:', parts);
                    console.log('ðŸ“± Emotion code:', emotionCode);
                    console.log('ðŸ“± Display text:', displayText);
                    
                    // Apply emotion based on response
                    this.applyResponseEmotion(emotionCode);
                }
                
                this.responseDisplay.textContent = displayText;
                this.responseDisplay.classList.add('show');
            }
            
            hideResponse() {
                this.responseDisplay.classList.remove('show');
                // Reset to default blue eyes when response is hidden
                if (this.roboEyes) {
                    console.log('ðŸ”µ Resetting to blue eyes after response');
                    this.roboEyes.setMood(0); // DEFAULT emotion
                    this.roboEyes.setDisplayColors('#000000', '#00aaff'); // Blue eyes
                    this.roboEyes.setTearColor(null); // Reset tear color to default
                    this.roboEyes.setWateryEyes(false); // Reset watery eyes
                    this.roboEyes.setSweat(false);
                    this.roboEyes.setHFlicker(false);
                    this.roboEyes.setVFlicker(false);
                    
                    // Reset eye sizes to default
                    this.roboEyes.eyeLwidthCurrent = this.roboEyes.eyeLwidthDefault;
                    this.roboEyes.eyeRwidthCurrent = this.roboEyes.eyeRwidthDefault;
                    this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault;
                    this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault;
                }
                // Also reset robot state to normal listening mode
                this.setRobotState('NORMAL');
            }
            
            applyResponseEmotion(emotionCode) {
                if (!this.roboEyes) return;
                
                console.log('ðŸŽ­ Applying response emotion:', emotionCode);
                
                switch (emotionCode) {
                    case 0: // DEFAULT
                        this.roboEyes.setMood(0);
                        this.roboEyes.setDisplayColors('#000000', '#00aaff'); // Blue eyes
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(false);
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(false);
                        // Start blinking for default emotion
                        this.startBlinking();
                        break;
                        
                    case 1: // TIRED
                        this.roboEyes.setMood(1);
                        this.roboEyes.setDisplayColors('#000000', '#8800ff'); // Purple eyes
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(true);
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(false);
                        // Stop blinking for tired emotion
                        this.stopBlinking();
                        break;
                        
                    case 2: // ANGRY
                        this.roboEyes.setMood(2);
                        this.roboEyes.setDisplayColors('#000000', '#ff0000'); // Red eyes
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(false);
                        this.roboEyes.setHFlicker(true, 5);
                        this.roboEyes.setVFlicker(false);
                        // Stop blinking for angry emotion
                        this.stopBlinking();
                        break;
                        
                    case 3: // HAPPY
                        this.roboEyes.setMood(3);
                        this.roboEyes.setDisplayColors('#000000', '#00ff00'); // Green eyes
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(false);
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(false);
                        // Trigger laugh animation for happy emotion
                        this.roboEyes.anim_laugh();
                        // Stop blinking for happy emotion
                        this.stopBlinking();
                        break;
                        
                    case 4: // THINKING (shouldn't happen in response, but just in case)
                        this.roboEyes.setMood(4);
                        this.roboEyes.setDisplayColors('#000000', '#ffaa00'); // Orange eyes
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(false);
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(true, 3);
                        // Stop blinking for thinking emotion
                        this.stopBlinking();
                        break;
                        
                    case 5: // CRYING
                        this.roboEyes.setMood(1); // Use TIRED mood for droopy eyes
                        this.roboEyes.setDisplayColors('#000000', '#88aaff'); // Soft blue teary eyes
                        this.roboEyes.setTearColor('#66ddff'); // Bright cyan tears for visibility
                        this.roboEyes.setWateryEyes(true); // Enable watery/glossy eyes effect
                        this.roboEyes.setSweat(true); // Enable tears
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(true, 2); // Gentle sobbing flicker
                        
                        // Stop blinking for crying emotion (crying creates its own eye movement)
                        this.stopBlinking();
                        
                        // Make tears bigger and more visible
                        this.roboEyes.sweat1.width = 6;
                        this.roboEyes.sweat1.height = 12;
                        this.roboEyes.sweat2.width = 5;
                        this.roboEyes.sweat2.height = 10;
                        this.roboEyes.sweat3.width = 4;
                        this.roboEyes.sweat3.height = 8;
                        
                        // Trigger sad/confused animation for crying effect
                        if (Math.random() < 0.6) {
                            this.roboEyes.anim_confused();
                        }
                        break;
                        
                    default:
                        // Default to normal blue eyes
                        this.roboEyes.setMood(0);
                        this.roboEyes.setDisplayColors('#000000', '#00aaff');
                        this.roboEyes.setTearColor(null); // Reset tear color
                        this.roboEyes.setWateryEyes(false); // Reset watery eyes
                        this.roboEyes.setSweat(false);
                        this.roboEyes.setHFlicker(false);
                        this.roboEyes.setVFlicker(false);
                        // Start blinking for default case
                        this.startBlinking();
                        break;
                }
            }
            
            showThinkingBubble() {
                this.thinkingBubble.classList.add('show');
                
                // Animate through different thinking messages
                let messageIndex = 0;
                this.thinkingInterval = setInterval(() => {
                    this.thinkingText.textContent = this.thinkingMessages[messageIndex];
                    messageIndex = (messageIndex + 1) % this.thinkingMessages.length;
                }, 200); // Change message every second
            }
            
            hideThinkingBubble() {
                this.thinkingBubble.classList.remove('show');
                if (this.thinkingInterval) {
                    clearInterval(this.thinkingInterval);
                    this.thinkingInterval = null;
                }
            }
            
            // Custom blinking system for normal mode
            startBlinking() {
                console.log('ðŸ‘ï¸ Starting custom blinking for normal mode');
                
                // Stop any existing blink interval
                this.stopBlinking();
                
                // Start blinking every 1.5 seconds
                this.blinkInterval = setInterval(() => {
                    if (this.roboEyes && this.robotState === 'NORMAL' && !this.isBlinking) {
                        this.performBlink();
                    }
                }, 1500); // 1.5 seconds
            }
            
            stopBlinking() {
                if (this.blinkInterval) {
                    clearInterval(this.blinkInterval);
                    this.blinkInterval = null;
                }
            }
            
            performBlink() {
                if (!this.roboEyes || this.isBlinking) return;
                
                console.log('ðŸ‘ï¸ Performing custom blink');
                this.isBlinking = true;
                
                // Close eyes quickly
                this.roboEyes.eyeL_open = false;
                this.roboEyes.eyeR_open = false;
                this.roboEyes.eyeLheightCurrent = 5; // Small height for closed eyes
                this.roboEyes.eyeRheightCurrent = 5;
                
                // Open eyes after 150ms for a noticeable blink
                setTimeout(() => {
                    if (this.roboEyes) {
                        this.roboEyes.eyeL_open = true;
                        this.roboEyes.eyeR_open = true;
                        this.roboEyes.eyeLheightCurrent = this.roboEyes.eyeLheightDefault;
                        this.roboEyes.eyeRheightCurrent = this.roboEyes.eyeRheightDefault;
                        this.isBlinking = false;
                    }
                }, 150); // 150ms blink duration for noticeable effect
            }
            
            // Cleanup function to prevent memory leaks
            cleanup() {
                if (this.commandTimer) {
                    clearTimeout(this.commandTimer);
                    this.commandTimer = null;
                }
                if (this.silenceTimer) {
                    clearTimeout(this.silenceTimer);
                    this.silenceTimer = null;
                }
                if (this.thinkingInterval) {
                    clearInterval(this.thinkingInterval);
                    this.thinkingInterval = null;
                }
                if (this.emotionInterval) {
                    clearInterval(this.emotionInterval);
                    this.emotionInterval = null;
                }
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                    this.cursorTimeout = null;
                }
                if (this.blinkInterval) {
                    clearInterval(this.blinkInterval);
                    this.blinkInterval = null;
                }
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new RoboEyesApp();
            
            // Cleanup when page unloads to prevent memory leaks
            window.addEventListener('beforeunload', () => {
                app.cleanup();
            });
        });
        
        console.log('ðŸ¤– FluxGarage RoboEyes - Pure Eyes Mode');
        console.log('Keyboard: F=fullscreen, B=blink, C=cyclops, R=confused, L=laugh, S=sweat');
        console.log('Double-click or double-tap for fullscreen');
    </script>
</body>
</html>